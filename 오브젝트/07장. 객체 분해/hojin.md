해당 장에서는 인간의 단기 기억 문제를 극복하기 위해 사용되는 **분해**와 **추상화**에 대해 알아본다.

또한, 객체 지향이 등장하기까지 **이전의 설계 방식의 한계점을 확인**하고 이를 어떻게 극복해 나갔는지 알아보는 시간을 가진다.

 

---

# 1. 프로시저 추상화와 데이터 추상화

현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 메커니즘은 **프로시저 추상화**와 **데이터 추상화**이다.

프로시저 추상화?

- 소프트웨어가 무엇을 해야 할지 추상화한다.

데이터 추상화?

- 소프트웨어가 무엇을 알아야 할지 추상화한다.

프로그래밍 관점에서 객체지향은 데이터 추상화와 프로시저 추상화를 함께 포함한 **클래스를 이용해 시스템을 분해**하는 것.

일반적으로 객체지향이 전통적인 기능 분해 방법에 비해 효과적이라고 말하는 이유는 무엇인가?

전통적 기능 분해 방식에 대해 먼저 이해해보자.

---

# 2. 프로시저 추상화와 기능 분해

## 메인 함수로서의 시스템

시스템은 필요한 더 작은 작업으로 분해될 수 있는 하나의 커다란 메인 함수이다.

전통적인 기능 분해 방법은 **하향식 접근법**을 따른다.

최상위 기능에서 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다.

- 하위 기능은 상위 기능보다 덜 추상적이며, 더 구체적이다.

## 급여 관리 시스템

이번 예시에서는 직원 정보와 소득 세율을 통해 급여를 계산하는 **시스템을 하향식 접근법으로 기능을 분해하는 과정**을 확인한다.

먼저, 메인 함수로서의 급여 관리 시스템은 아래와 같이 나타낸다.

<img width="736" height="207" alt="그림 7-1" src="https://github.com/user-attachments/assets/808622cc-14cc-45b2-a3ba-0de891d8ea8e" />

**기능 분해 방법에서는 기능을 중심으로 필요한 데이터를 결정**한다.

하향식 기능 분해 접근법은 먼저 필요한 기능을 생각하고, 이 기능을 분해하고 정제해 나가며 필요한 데이터의 종류와 저장 방식을 식별한다.

이것은 유지보수에 다양한 문제를 야기하는데, 이 문제점을 이해하며 객체지향의 장점을 이해할 수 있도록 해보자.

## 급여 관리 시스템 구현

급여 관리 시스템을 기능 관점에서 분해해가며 코드로 옮겨 보자.

최상위 문장은 기능(문장)은 아래와 같다.

***“직원의 급여를 계산한다.”***

이를 구현하기 위해 내용을 세분화해보자.

```html
직원의 급여를 계산한다.
		
		사용자로부터 소득세율을 입력받는다.
		
		직원의 급여를 계산한다.
		
		양식에 맞게 결과를 출력한다.
```

### 소득세율 입력 분해

```html
직원의 급여를 계산한다.
		
		사용자로부터 소득세율을 입력받는다.
			**"세율을 입력하세요 : "라는 문장을 화면에 출력한다**
			**키보드를 통해 세율을 입력받는다**
```

이를 함수로 구현한다.

```java
    private static double getTaxRate() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("세율을 입력하세요: ");
        double taxRate = scanner.nextDouble();
        return taxRate;
    }
```

### 급여 계산 분해

```html
직원의 급여를 계산한다.
		
		사용자로부터 소득세율을 입력받는다.
			**"세율을 입력하세요 : "라는 문장을 화면에 출력한다**
			**키보드를 통해 세율을 입력받는다**
			
		직원의 급여를 계산한다.
			**전역 변수에 저장된 직원의 기본급 정보를 얻는다
			급여를 계산한다.**
```

이를 함수로 나타내면 아래와 같다.

```java
    private static int calculateSalary(String name,double taxRate) {
        int index = employees.indexOf(name);
        double basePay = basePays.get(index);
        return (int)(basePay - (basePay * taxRate));
    }
```

### 결과 출력 분해

```html
직원의 급여를 계산한다.
		
		사용자로부터 소득세율을 입력받는다.
			**"세율을 입력하세요 : "라는 문장을 화면에 출력한다**
			**키보드를 통해 세율을 입력받는다**
			
		직원의 급여를 계산한다.
			**전역 변수에 저장된 직원의 기본급 정보를 얻는다
			급여를 계산한다.**
			
		양식에 맞게 결과를 출력한다.
			**"이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.**
```

함수로 구현한다.

```java
    private static void describeResult(String name, double salary) {
        System.out.println("이름: " + name + ", 급여: " + salary);
    }
```

이렇게 최상위 기능 분해 예제에서 알 수 있듯이, 하향식 기능 분해는 아래의 과정이다.

- 최상위 메인함수를 정의하고, 메인 함수를 세부적인 단계로 분해하는 방법이다.

이를 트리구조로 나타내고, 메인 함수를 코드로 구현하면 다음과 같다.

<img width="970" height="373" alt="그림 7-2" src="https://github.com/user-attachments/assets/d033354e-ed11-4b3d-8722-3e959f7e1a9c" />

```java
    public static void main(String[] args) {
        double taxRate = getTaxRate();
        int pay = calculateSalary("직원A",taxRate);
        describeResult("직원A",pay);
    }
```

하향식 설계 방식은 체계적이고 이상적인 방법으로 보이지만, 이것이 문제로 다가온다.

- 우리가 사는 세계는 그렇게 체계적이지도, 이상적이지도 않다.

## 하향식 기능 분해의 문제점

하향식 기능 분해의 문제점을 5가지로 추려낼 수 있다.

### 1. 시스템은 하나의 메인 함수로 구성되지 않는다.

어떤 시스템도 최초에 릴리즈됐던 모습을 그대로 유지하지 않는다.

지속적으로 기존 기능의 변경 및 신규 기능 추가 작업을 반복하게 된다.

- 이런 상황에서 모든 기능을 자식 노드로 가지는 하나의 메인 함수를 정의하는 것이 가능한가?

하향식 접근법은 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않다.

- **현대적인 시스템은 동등한 수준의 다양한 기능으로 구성**된다.

### 2. 메인 함수의 빈번한 재설계

```java
    public static void main(String[] args) {
        double taxRate = getTaxRate();
        int pay = calculateSalary("직원A",taxRate);
        describeResult("직원A",pay);
    }
```

위 코드를 보자. 하위 기능의 변경 및 추가가 있을 때마다 매번 메인 함수를 수정해야 한다.

결과적으로 기존 코드의 빈번한 수정으로 인한 버그 발생 확률이 높아진다.

- 시스템이 변경에 취약해 질 수 밖에 없다.
- 상위 기능과 하위 기능이 강하게 결합되기 때문이다.

### 3. 비즈니스 로직과 사용자 인터페이스의 강한 결합

사용자로부터 입력받는 함수를 다시 살펴보자.

```java
    public static void main(String[] args) {
        double taxRate = getTaxRate();
        int pay = calculateSalary("직원A",taxRate);
        describeResult("직원A",pay);
    }
    
    private static double getTaxRate() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("세율을 입력하세요: ");
        double taxRate = scanner.nextDouble();
        return taxRate;
    }
    
    ..........
```

급여를 계산하는 비즈니스 로직이 사용자 입력하는 함수와 한데 섞여 있는 것을 볼 수 있다.

- 코드 안에서 **비즈니스 로직과 사용자 인터페이스 로직이 강하게 결합**된다.

문제는 사용자 인터페이스는 시스템 내에서 가장 자주 변경되는 부분이다.

- 비즈니스 로직까지 사용자 인터페이스 변경에 영향을 받는데, 이는 기본적으로 변경에 불안정한 아키텍처를 낳는다..

### 4. 성급하게 결정된 실행 순서

하향식 접근법의 설계는 처음부터 구현을 염두에 두기 때문에 **함수들의 실행 순서를 정의하는 시간 제약을 강조**한다.

실행 순서, 조건 등의 제어 구조를 미리 결정해야 하기 때문에 **중앙집중 제어 스타일의 형태**를 띨 수밖에 없다.

문제는 함수의 제어 구조는 빈번하게 변경되며, 이는 기존에 결정된 함수의 제어 구조를 전반적으로 수정해야함을 암시한다.

하향식 접근법을 통해 분해한 함수들은 **재사용하기도 어렵다.**

- 상위 함수가 강요하는 문맥 안에서만 의미를 가지기 때문이다.

이 모든 문제들의 원인은 결합도에 있다.

- 하위 함수는 상위 함수가 강요하는 문맥에 강하게 결합되기 때문이다.

### 5. 데이터 변경으로 인한 파급효과

하위 함수에서는 전역적으로 선언된 데이터들을 사용하고 있다.

- 어떤 데이터가 어떤 함수에 의존하는지 파악하기 어려워진다.

거대한 시스템에서 모든 함수를 열어 데이터를 사용하고 있는지 확인해봐야 하기 때문이다.

- 변경에 의한 영향도 파악이 어려워져 코드 수정을 꺼리게 하는 요인이다.

데이터 변경으로 인한 영향을 최소화하려면 함께 **변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야** 한다.

- 의존성 관리의 핵심이며, 잘 정의된 **퍼블릭 인터페이스**를 통해 **변경되는 부분에 대한 접근을 통제**하자.

---

# 3. 모듈

정보 은닉은 시스템을 모듈 단위로 분해하기 위한 기본 원리이며,

시스템에서 자주 변경되는 부분을 안정적인 인터페이스 뒤로 감추는 것이 핵심이다.

모듈은 다음 두 가지 비밀을 감춰야 한다.

- 복잡성 : 모듈을 **추상화할 수 있는 간단한 인터페이스를 제공**한다.
- 변경 가능성 : **변경 가능한 설계 결정은 모듈 내부에** 감추고, 잘 변경되지 않을 인터페이스를 제공한다.

여기서 혼동하지 말아야할 것이, 정보 은닉과 데이터 캡슐화는 다르다는 것이다.

- 데이터 캡슐화 : 비밀의 한 종류인 데이터를 감추는 **캡슐화의 한 종류**이다.

이제, 직원과 급여 계산을 캡슐화해보자.

```java
public class Employee {
    private static List<String> employees = new ArrayList<>(List.of("직원A", "직원B", "직원C"));
    private static List<Integer> basePays = new ArrayList<>(List.of(400, 300, 250));

    private String name;
    private double taxRate;

    public Employee(String name, double taxRate) {
        this.name = name;
        this.taxRate = taxRate;
    }

    public int calculateSalary() {
        int index = employees.indexOf(name);
        double basePay = basePays.get(index);
        return (int)(basePay - (basePay * taxRate));
    }
}

// 메인함수 급여 계산 함수 호출
public class Main {
    public static void main(String[] args) {
        double taxRate = getTaxRate();

        Employee employee = new Employee("직원A",taxRate);
        int pay = employee.calculateSalary();
        ...........
    }
    ...................
}
```

## 모듈의 장점과 한계

Employee 모듈화를 통해 알 수 있는 장점이다.

모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.

- 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한한다.

비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.

- Employee 모듈은 비즈니스 로직과 관련된 관심사만을 담당한다.

네임스페이스 오염을 방지한다.

- 변수와 함수를 모듈 내부에 포함시키기 때문에, 다른 모듈에서도 동일한 이름을 사용할 수 있다.
- 이름 충돌 위험을 완화한다.

그러나, 여전히 아래와 같은 한계점이 존재한다.

**인스턴스 개념을 제공하지 않는다.**

- 가장 추상적인 개념으로만 코드를 작동시킬수 있다.
- 개별 직원을 독립적인 단위로 다룰 수 없다.

---

# 4. 데이터 추상화와 추상 데이터 타입

기능 분해의 시대에 사용되던 절차형 언어들은 새로운 타입을 추가하는 것이 불가능하거나 제한적이었다.

이 시대의 프로그램에서 사용하는 주된 추상화는 프로시저 추상화였는데, 이는 프로그램의 표현력을 향상시키는 데 한계가 있었다.

바바라 리스코프는 **대안으로 데이터 추상화의 개념을 제안**했다.

추상 데이터 타입 정의를 기반으로 인스턴스를 생성하는 것은 가능하지만, 여전히 데이터와 기능을 분리해서 바라본다.

아래 예시를 보자. (C의 struct는 엄밀히 말해 추상 데이터 타입으로 보기 어려우나, 이해를 위한 용도로 작성하였다.)

```c
typedef struct {
    int items[100];
    int top;
} Stack;

void push(Stack* s, int value);
int pop(Stack* s);
int isEmpty(Stack* s);
```

데이터(구조체)와 기능(함수)은 여전히 별도로 존재한다.

데이터(구조체)와 기능(함수)은 **논리적으로 연관되어 있지만, 언어 차원에서 강제적으로 묶이지 않는다**는 점을 확인할 수 있다.

- 추상 데이터 타입은 말 그대로 시스템의 상태를 저장할 데이터를 표현한다.

---

# 5. 클래스

## 클래스는 추상 데이터 타입인가?

추상 데이터 타입과 클래스는 동일하지 않다.

가장 핵심적인 차이는 **클래스는 상속과 다형성을 지원**하지만, 추상 데이터 타입은 그렇지 않다.

**추상 데이터 타입은 타입을 추상화**한 것이고, **클래스는 절차를 추상화**한 것이다.

프로그래밍 관점에서는 아래와 같이 나눌 수 있다.

상속/다형성을 지원하는 것은 객체지향 프로그래밍

상속/다형성을 지원하지 않는 **추상 데이터 타입의 패러다임은 객체기반 프로그래밍**

추상 데이터 타입과 클래스의 차이를 이해하기 위해

Employee 타입의 calculatePay와 monthlyBasePay 오퍼레이션을 살펴보자.

<img width="865" height="270" alt="그림 7-3" src="https://github.com/user-attachments/assets/e9855a03-f7ca-4c3f-8a60-979c5e7fcf37" />

**타입 추상화는** 오퍼레이션을 기준으로 타입을 통합하는 **데이터 추상화 기법**이다.

- 이 자료형이 **어떤 데이터를 가지고 있고**, 내부 구현을 몰라도 **어떤 연산이 가능한지만 알려준다.**
- 사용 예시) 자료구조

클래스 기반 객체지향 프로그래밍 기준 Employee를 보자.

<img width="837" height="278" alt="그림 7-4" src="https://github.com/user-attachments/assets/8fd68f5b-a57f-4db4-99c1-ad5b4409a7f9" />

Employee의 구현체의 각 절차에 따라 나누어짐을 확인할 수 있다.

- 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다.
- 책임을 기준으로 객체 타입을 나누어 설계할 수 있다는 점에서 타입 추상화와 다른 점이다.

## 언제 추상 데이터 타입을 선택할까?

추상 데이터 타입과 객체지향 설계의 유용성은 설계에 요구되는 변경의 압력이 **“타입 추가”에 관한 것인지, 아니면 “오퍼레이션 추가”에 관한 것인지**에 따라 달라진다.

객체지향을 선택하는 경우

- **타입 추가라는 변경의 압력이 더 강한 경우**
- 이 경우, 추상 데이터 타입은 타입을 체크하는 클라이언트 코드를 일일이 찾아 수정해야만 한다.

추상 데이터 타입을 선택하는 경우

- 변경의 주된 압력이 오퍼레이션을 추가하는 경우
- 객체지향의 경우, 새로운 오퍼레이션을 추가하기 위해서 상속 계층에 속하는 모든 클래스를 한번에 수정해야 한다.
