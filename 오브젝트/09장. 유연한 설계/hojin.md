# 1. 개방 폐쇄 원칙

개방 폐쇄 원칙의 정의 : 소프트웨어 개체는 **확장에 대해 열려** 있어야 하고, **수정에 대해서는 닫혀** 있어야 한다.

여기서, ‘확장’과 ‘수정’을 동작과 코드의 관점을 반영하면 아래와 같다.

- 확장 : 변경에 맞게 새로운 동작을 추가하여 기능을 확장한다.
- 수정 : 기존 코드를 수정하여 동작을 추가하거나 변경한다.

코드를 수정하지 않고, 기능을 추가하는 것이 이질적인 것처럼 보인다.

어떻게 코드를 수정하지 않고 새로운 코드를 추가할까?

## 런타임 의존성이 변경되도록 설계하라.

개방-폐쇄 원칙은 런타임 의존성과 컴파일 타임 의존성에 관한 이야기이며, **런타임 의존성은 실행 시 협력에 참여하는 객체들 사이의 관계**이다.

앞서 우리는 영화 예매 시스템에서 의존성 설계를 수행한 바 있다.

![image.png](attachment:e70a69ee-7c99-499e-b435-89c6f80852b3:image.png)

Movie에서 구현체에 의존하는 것이 아닌 추상체에 의존하여 컴파일/런타임 의존성이 다름을 알 수 있다.

이는 기존 코드 수정없이 기능을 추가하는 것을 돕는데, NonDiscountPolicy 정책을 추가할 때, 단순히 구현체 클래스를 추가함으로써 이를 달성한 바 있다.

![image.png](attachment:d6c19847-899a-418b-8096-5f44fe65376b:image.png)

의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란,

**컴파일 타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조**이다.

## 추상화가 핵심이다.

개방 폐쇄 원칙의 핵심은 추상화에 의존하는 것인데, 추상화의 정의는 아래와 같다.

- 불필요한 부분은 생략하고, 핵심적인 부분만 남겨 복잡성을 극복하는 기법

개방 폐쇄 원칙 관점에서 남겨지는 부분은 **공통점을 반영한 추상화의 결과물**이다.

변하지 않은 부분인 핵심만을 남기고, **생략된 부분은 구현에 위임**함으로써 새로운 문맥에 맞게 기능을 추가할 수 있게 된다.

추상화 뿐 아니라 변경에 닫혀 있기 위해서는 **의존성의 방향 또한 매우 중요**하다.

![image.png](attachment:20e80b19-6900-4517-84cb-1bb171521d6e:image.png)

클라이언트에서 **추상체에 의존하는 방향으로 설계**해야 비로소 변경에 닫혀 있을 여지가 생긴다.

중요한 것은 **변하지 않는 것과 변하는 것을 정확하게 구분**하고 이를 추상화의 목적으로 삼아야 한다.

---

# 2. 생성 사용 분리

추상체에 의존하더라도, 개방-폐쇄 원칙을 위반할 수 있는데 올바르지 않은 객체 생성의 경우이다.

아래 코드를 보자.

```java
public class Movie {
		private DiscountPolicy discountPolicy;
		
		public Movie(String title, Duration runningTime, Money fee) {
				.....
				this.discountPolicy = new AmountDiscountPolicy(....);
		}
}
```

생성자에 DiscountPolicy 구현체를 직접 선언하고 있으며 Movie가 알아야 할 지식이 많아짐을 뜻한다.

알아야 할 **지식이 많아질수록 컨텍스트 확장에 제약**이 되는데, 예시의 문제는 아래와 같다.

동일한 클래스 안에서 객체 **사용과 사용이라는 두 목적의 코드가 공존**한다.

![image.png](attachment:5fff3c56-9c03-4dd4-91f0-f6fae4b81352:image.png)

유연한 객체 설계를 위해 객체 생성과 사용 목적의 코드를 분리해야한다.

가장 보편적인 방법은 **클라이언트에게 객체를 생성할 책임을 옮기는 것**이다.

![image.png](attachment:66ab9254-feb0-4947-bb3a-481157cefb79:image.png)

그림 9.4와 달리, 구체 인스턴스를 생성하는 책임을 클라이언트에게 맡김으로써 컨텍스트에 관한 정보를 클라이언트에 옮겼다.

이로써, Movie 내에서는 추상체(DiscountPolicy) 인스턴스 사용에만 집중할 수 있게 되었다.

## FACTORY 추가하기

만약, 클라이언트에서도 특정한 컨텍스트에 묶이지 않기를 바란다고 가정해보자.

이 경우 객체 생성과 관련한 책임만 전담하는 별도의 객체를 추가하고, 클라이언트가 이 객체를 사용하도록 만들 수 있다.

이렇게 **객체 생성에 특화된 객체를 FACTORY**라고 부른다.

![image.png](attachment:0f33d32a-803c-4ba0-8cc4-2aef777eee47:image.png)

객체 생성의 책임을 FACTORY로 위임함으로써, 클라이언트는 객체 생성에 대한 어떤 지식도 가지지 않을 수 있다.

## 순수한 가공물에 책임 할당

FACTORY는 도메인 모델에 속하지 않은 순수하게 기술적으로 생성되는 객체이다.

FACTORY의 특성을 알아보기에 앞서 객체 분해의 두가지 방식을 짚고 넘어가보자.

**표면적 분해(representational decomposition)**

도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 방식이며, 객체지향 설계를 위한 가장 기본적인 접근법이다.

**행위적 분해(behavioral decomposition)**

도메인 지식과 상관없이 시스템의 동작과 책임을 중심으로 설계하는 방식이다.

종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로 부족한 경우가 발생한다.

실제로는 데이터베이스 접근 객체와 같이 도메인 개념들을 초월하는 개념들을 필요로 한다.

모든 책임을 도메인 객체에 할당하면 높은 결합도, 낮은 응집도와 같은 문제점에 봉착할 가능성이 높아지는데,

책임을 할당하기 위해 **도메인과 무관한 인공적인 객체를 순수한 가공물** 이라고 한다.

순수한 가공물은 **책임을 할당할 도메인 객체가 존재하지 않을 때 선택**할 수 있는 방안이다.

---

# 3. 의존성 주입

객체의 사용과 생성을 분리하면, 외부의 객체가 생성된 인스턴스를 전달해야 함을 의미한다.

**외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결**하는 방법을 의존성 주입이라고 부른다.

의존성 주입에는 아래 세 가지 방법이 존재한다.

**생성자 주입(constructor injection)**

- **객체를 생성하는 시점**에 생성자를 통한 의존성 해결

**객체를 생성하는 시점에 주입해주어야 할 의존성을 명시**적으로 드러낸다.

이는 개발자로 하여금, 필요한 의존성을 드러내어 준다.

**setter 주입(setter injection)**

- **객체 생성 후** setter 메서드를 통한 의존성 해결

이미 생성된 객체에 의존성을 주입해주어 **런타임에 의존성 대상을 변경할 수 있다**는 장점이 있다.

한편 객체가 생성되기 위해 **어떤 의존성이 필수적인지 명시적으로 표현할 수 없다**는 단점이 상존한다.

**메서드 주입(method injection)**

- 메서드 실행 시 인자를 이용한 의존성 해결

메서드가 의존성을 필요로 하는 유일한 경우에 사용할 수 있다.

## 숨겨진 의존성은 나쁘다.

의존성 주입 방식에서 가장 널리 사용되는 대표적인 방법은 **SERVICE LOCATOR 패턴**이다.

**의존성을 해결할 객체들을 보관하는 일종의 저장소**이며, 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을 요청한다.

SERVICE LOCATOR 패턴은 의존성을 해결할 수 있는 쉽고 간단한 도구처럼 보이지만, **의존성을 감춘다는 큰 단점이 존재**한다.

Movie에서 DiscountPolicy 객체 의존성을 가지며, SERVICE LOCATOR를 통해 의존성을 주입한다고 가정해보자.

```java
Movie avatar = new Movie("아바타", Duration.ofMinutes(120), Money.wons(10000));
```

개발자는 완전한 상태의 객체임을 가정하지만, DiscountPolicy가 null이기에, NullPointerException 예외 발생의 위험이 도사린다.

이는 문제를 **발견할 시점을 런타임으로 미루면 숨겨진 의존성을 이해하기 어렵다**는 점을 상기해 준다.

이야기의 핵심은 의존성 주입이 SERVICE LOCATOR 패턴보다 좋다가 아니라, **명시적인 의존성이 숨겨진 의존성보다 좋다**는 것이다.

의존성을 구현 내부에 숨기면 숨길수록 코드를 이해하기도, 수정하기도 어려워진다.

---

# 4. 의존성 역전 원칙

상위 수준의 클래스가 하위 수준의 클래스에 의존하는 경우 변경에 취약하게 된다.

![image.png](attachment:7ec388d7-4204-4199-bd07-90b59d8f2826:image.png)

협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스이다.

이런 상위 수준의 클래스가 하위 클래스에 영향을 받는다면, 상위 클래스에서 매번 코드의 변경이 발생함을 의미한다.

- 이는 예기치 못한 버그의 발생 가능성을 높힌다..

앞서 **의존성의 방향이 중요하다는 사실**을 다시금 기억할 필요가 있다.

상위 클래스가 하위 클래스를 바라보지 않도록 충분히 추상화된 클래스에 의존하도록 해야한다.

![image.png](attachment:434e13c5-5265-4591-af0f-64fecc5d2b7d:image.png)

지금까지 살펴본 내용을 정리해보자.

- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
- 구체적인 사항은 추상화에 의존해야 하며, 추상화는 구체적인 사항에 의존해서는 안 된다.

이를 **의존성 역전 원칙**이라고 부른다.

## 의존성 의존 원칙과 패키지

의존성 역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권에도 적용된다.

객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈이다.

![image.png](attachment:46383da9-97b1-4a58-a9aa-53f300e6bf57:image.png)

위 예시는 Movie가 DiscountPolicy에 의존하고 있지만, 인터페이스(DiscountPolicy)가 서버 모듈에 위치하고 있다.

이는 클라이언트가 인터페이스에 의존하기 위해서, 인터페이스와 같은 패키지에 포함된 구현체 클래스도 함께 존재해야함을 의미한다.

DiscountPolicy에 변경사항이 없다면 Movie 클래스 또한 영향을 받지 않아야 하지만, Movie가 인터페이스 패키지에 의존하고 있어 재컴파일이 발생한다.

![image.png](attachment:b34caa26-891d-46d4-a6ba-e96d4413f783:image.png)

이를 극복하기 위해 추상화를 클라이언트가 속한 패키지에 포함시켜야 한다.

Movie를 추상체와 하나의 패키지로 모음으로써, 특정한 컨텍스트로부터 완벽하게 독립시켰다.

새로운 할인 정책의 자식 클래스를 구현하기만 하면, 상위 협력 관계를 온전히 재사용 할 수 있다.

이는, 구체 클래스와 함께 배포할 필요가 없어짐을 의미한다.

그림 9.9.와 9.10의 패키지 구조는 빌드의 속도에서 차이를 발생시키는데, 이유는 아래와 같다.

빌드 도구(maven,gradle 등)은 파일이 **마지막으로 수정된 시각(타임스탬프)를 기준으로 변경 여부를 판단**한다.

1. 9.9 구조에서는 인터페이스와 구현체가 같은 모듈에 있어, 구현체 추가만으로도 인터페이스의 .class가 갱신되어 Movie가 재컴파일된다.
2. Movie가 인터페이스에만 의존해도, .class 파일 변경이 있으면 재컴파일된다.
3. 9.10 구조는 인터페이스가 클라이언트 모듈에 있어, 구현체가 추가되어도 Movie가 재컴파일되지 않는다.

핵심은 **인터페이스는 그것을 사용하는 쪽(클라이언트)의 모듈에 두어야, 의존성 역전 원칙과 변경의 최소 전파라는 객체지향 설계의 핵심을 지킬 수 있다**는 것이다.

---
